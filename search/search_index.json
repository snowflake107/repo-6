{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Matrix Requirements SDK","text":"<p>This document is an evolving guide to using the Matrix Requirements SDK (github page here). You can use the SDK in two ways:</p> <ol> <li>To integrate with the Matrix Requirements web application, a demo instance of which is here. This involves inheriting functionality from certain classes and registering interest in certain \"plugin\" functionality. We have a github project which you can clone and go to town writing plugins.</li> <li>To talk to a Matrix Requirement Instance from a different environment, such as Node. This is more about querying the database for interesting data, importing data, or making queries across multiple projects. This document will focus on this case, as we can more efficiently introduce important concepts in a \"textual\" environment.</li> </ol>"},{"location":"#how-do-i-get-it","title":"How do I get it?","text":"<p>The SDK is available as an NPM package at https://www.npmjs.com/package/matrix-requirements-sdk. For this guide, we'll create JavaScript in a Node project to illustrate our points. The steps below set up an environment and a simple code library to make connecting to a Matrix Instance easier. </p> <p>From a shell prompt, run:</p> <pre><code>mstanton@darkstar:~/examples/users-guide (main)$ npm install matrix-requirements-sdk\n\nadded 1 package, and audited 54 packages in 1s\n\n1 package is looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n</code></pre> <p>To make it easy to connect to a Matrix Instance, we'll write some code once that gets your API Token and Instance URL from a JSON file. Create a file called <code>credentials.json</code> in the same directory like:</p> <pre><code>{\n  \"clouds5\": {\n    \"token\": \"Token &lt;INSERT YOUR TOKEN HERE&gt;\",\n    \"url\": \"https://clouds5.matrixreq.com\"\n  }\n}\n</code></pre> <p>Now create a file <code>lib.js</code> with the following code:</p> lib.js<pre><code>const fs = require(\"fs\");\nconst sdk = require(\"matrix-requirements-sdk/server\");\n\n// Securely connect to a server with stored credentials\nasync function getServerConnection(key) {\n    const credentialsFilename = \"./credentials.json\";\n    const db = JSON.parse(fs.readFileSync(credentialsFilename, \"utf-8\"));\n    return await sdk.createConsoleAPI(db[key]);\n}\n\nasync function getServerAndProject(connection, projectName) {\n    if (connection == undefined) {\n        connection = \"clouds5\";\n    }\n    if (projectName == undefined) {\n        projectName = \"WHEELY_OBSERVABLE\";\n    }\n    const server = await getServerConnection(connection);\n    const wheely = await server.openProject(projectName);\n    return [server, wheely];\n}\n\nmodule.exports = { sdk, getServerConnection, getServerAndProject };\n</code></pre> <p><code>lib.js</code> wraps up getting the correct API Token for each Matrix Instance you'd like to connect to. Now let's use this library to list all the Projects available on a Matrix Instance.</p> list-projects.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    // List the projects available on this server:\n    console.log((await server.getProjects()).join(\", \"));\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Save this file as <code>list-projects.js</code> and run it at the command prompt. If you've set up your credentials file to point to the correct server and token you should receive output similar to the following:</p> <pre><code>mstanton@darkstar:~/examples/users-guide (main)$ node list-projects.js\nALM2, ALMSandbox, INSULINEPEN_SDK, MyWheely, PRINT, PRINT_ORG, QMS, QMS_FILE, TESTING_PRINT, TOOLS, \nWHEELY, WHEELY_CLEAN, WHEELY_CLIENT_TESTS, WHEELY_OBSERVABLE\n</code></pre> <p>From now on, we'll use <code>getServerConnection()</code> to make our connection to a Matrix Instance.</p>"},{"location":"#project-information","title":"Project Information","text":"<p>We can provide some characterization of our projects. What categories of items do they store? We'll use the SDK to investigate this for two projects on the server,  and show the results in an HTML table. Run the following code to produce the table:</p> characterize-projects.js<pre><code>const lib = require(\"./lib.js\");\n\nfunction getCharacterizations(projects) {\n  function makeTable(proj) {\n    const itemConfig = proj.getItemConfig();\n    let res = '&lt;table&gt;&lt;thead&gt;&lt;th scope=\"row\"&gt;Item&lt;/th&gt;&lt;th scope=\"row\"&gt;Fields&lt;/th&gt;&lt;/thead&gt;&lt;tbody&gt;';\n    let cats = itemConfig.getCategories();\n    // Ignore DOCs and REPORTs for now.\n    cats.splice(cats.indexOf(\"DOC\"), 1);\n    cats.splice(cats.indexOf(\"REPORT\"), 1);\n    for (let cat of cats) {\n      // Get the fields of the category.\n      let fields = [];\n      for (let field of itemConfig.getItemConfiguration(cat).fieldList) {\n          fields.push(`${field.label}(&lt;i&gt;${field.fieldType}&lt;/i&gt;)`);\n      }\n      let renderedFields = fields.join(\", \");\n      res += `&lt;tr&gt;&lt;td&gt;${cat}&lt;/td&gt;&lt;td&gt;${renderedFields}&lt;/td&gt;&lt;/tr&gt;`;\n    }\n    res += `&lt;/tbody&gt;&lt;/table&gt;`;\n    return res;\n  }\n  let rows = \"\";\n  for (let project in projects) {\n    rows += `&lt;tr&gt;&lt;td&gt;${projects[project].getName()}&lt;/td&gt;&lt;td&gt;${makeTable(projects[project])}&lt;/td&gt;&lt;/tr&gt;\\n`\n  }\n  return `&lt;table&gt;${rows}&lt;/table&gt;`;\n}\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    let projects = {};\n    projects.wheely = await server.openProject(\"WHEELY_OBSERVABLE\");\n    projects.insulin = await server.openProject(\"INSULINEPEN_SDK\");\n    console.log(getCharacterizations(projects));\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Here is the HTML output from running <code>node ./characterize-projects.js</code>. The tables show the Item Categories in each project, and also the Fields for each kind of item. In parenthesis, you see the type of the field. This is handy later when you want to examine or modify the fields.</p> WHEELY_OBSERVABLEItemFieldsFOLDERContents(richtext), Labels(labels)SIGNfilter(filter_file), signature(signature), output(signatureControl), Labels(labels), Attachments(fileManager), signCache(signCache)REQDescription(richtext), References(links), Tasks(tasksControl), Labels(labels), some crosslinks(crosslinks)UCDescription(richtext), Tasks(tasksControl), Use Case Steps(test_steps), Labels(labels), A markdown field(ui-plugin-mdeditor)RISKRisk(risk2), Cannot be reduced any further(checkbox), Benefits outweigh remaining risk(checkbox), Justification / Comments(richtext), Tasks(tasksControl), Labels(labels)SPECDescription(richtext), References(links), Tasks(tasksControl), Labels(labels)TCDescription(richtext), Tasks(tasksControl), Steps(test_steps), Labels(labels), Steplist Simple(steplist), checkers(checkbox), a user man(user), gate(gateControl), crosslinks(crosslinks)XTCDescription(richtext), Version(textline), Tester(user), Test Date(date), Test Run Result(test_result), Tasks(tasksControl), Test Case Steps(test_steps_result), Labels(labels) INSULINEPEN_SDKItemFieldsFOLDERContents(richtext), Labels(labels)SIGNfilter(filter_file), signature(signature), output(signatureControl), Labels(labels), Attachments(fileManager), signCache(signCache)REQUser Profile(dropdown), Description(richtext), My section(section), References(links), Labels(labels), xxxx(richtext)UCDescription(richtext), Use Case Steps(test_steps), Labels(labels)SPECDescription(richtext), References(links), Labels(labels)TCDescription(richtext), Steps(test_steps), Labels(labels)RISKRisk(risk2), Cannot be reduced any further(checkbox), Benefits outweigh remaining risk(checkbox), Justification / Comments(richtext), Tasks(tasksControl), Labels(labels)XTCDescription(richtext), Version(textline), Tester(user), Test Date(date), Test Run Result(test_result), Test Case Steps(test_steps_result), Labels(labels) <p>Note that both projects have an Item of Category <code>REQ</code>, but the fields are a bit different. In this case, we see project <code>INSULINEPEN_SDK</code> has a \"User Profile\" dropdown field, which <code>WHEELY_CLIENT_TESTS</code> doesn't have. This is because each project may define it's own categories, and those categories may consist of whatever fields the project owner considers important.</p>"},{"location":"#items","title":"Items","text":"<p>Let's have a look at some actual Items. We can find some Item Ids using project method <code>searchForIds()</code>:</p> get-item-ids.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    // List the projects available on this server:\n    const project = await server.openProject(\"WHEELY_OBSERVABLE\");\n    const reqs = await project.searchForIds(\"mrql:Category=REQ\");\n    console.log(reqs.join(\", \"));\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Running this at the command prompt returns a list of Item Ids returned by the query:</p> <pre><code>mstanton@darkstar:~/examples/users-guide (main)$ node get-item-ids.js\nREQ-1, REQ-2, REQ-3, REQ-4, REQ-5, REQ-6, REQ-7, REQ-8, REQ-9, REQ-10, REQ-11, REQ-12,\nREQ-13, REQ-14, REQ-15, REQ-16, REQ-17, REQ-18, REQ-19, REQ-20, REQ-21, REQ-22\nmstanton@darkstar:~/examples/users-guide (main)$ \n</code></pre> <p>The search query returned all of the items of type REQ in the <code>WHEELY_OBSERVABLE</code> project. Let's gather all information on the first one of the list:</p> get-one-item.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    // List the projects available on this server:\n    const project = await server.openProject(\"WHEELY_OBSERVABLE\");\n    const reqs = await project.searchForIds(\"mrql:Category=REQ\");\n    const wheelyFirstREQ = await project.getItem(reqs[0]); \n    console.log(\"ID: \" + wheelyFirstREQ.getId());\n    console.log(\"Title: \" + wheelyFirstREQ.getTitle());\n    const descriptionHandler = wheelyFirstREQ.getSingleFieldByName(\"Description\").getHandler();\n    const desc = descriptionHandler.getHtml();\n    console.log(`Description: ${desc}`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>We know from the table above for <code>WHEELY_OBSERVABLE</code> that a <code>REQ</code> Item should have five fields, one of which is Description. We also know that Description is a Richtext field. The SDK provides an appropriate object to manipulate each type of field. There are about ~20 built-in field types, and it's possible to write plug-ins that offer additional field types. The field types are managed by objects called Handlers. Every Handler has a <code>getData()</code> method which returns a string representation of the data stored in the database. But some handlers offer additional methods to make it easier to manipulate thier unique data type. The Handler for Richtext fields offers two extra methods, which are there simply to indicate the type of data the Handler deals with: html. The methods are <code>getHtml()</code> which returns an HTML string, and <code>setHtml()</code> which sets the data as an HTML string.</p> <p>Running the code above produces:</p> <pre><code>mstanton@darkstar:~/examples/users-guide (main)$ node get-one-item.js\nID: REQ-1\nTitle: Design / Looks\nDescription: &lt;div&gt;The wheelchair should not look like a medical device but like something which looks\nnice to kids from 6 to 10 years.&lt;/div&gt;\n&lt;div&gt;&amp;nbsp;&lt;/div&gt;\nmstanton@darkstar:~/examples/users-guide (main)$ \n</code></pre> <p>Below is an overview of the services provided by the Item class. Note that we ship a TypeScript binding in the SDK, so descriptive types are available if you like (you can also see the full reference docs for Item here):</p> <p><pre><code>class Item {\n    // Basic information\n    getId(): string;\n    isFolder(): boolean;\n    getType(): string;\n    getCategory(): Category;\n    getMaxVersion(): number | undefined;\n    getHistory(): IItemHistory[];\n\n    // getters/setters for changeable information\n    getCreationDate(): string | undefined;\n    setCreationDate(creationDate: string): Item;\n    getTitle(): string;\n    setTitle(title: string): Item;\n\n    // uplinks and downlinks\n    getDownlinks(): IReference[];\n    hasDownlink(id: string): boolean;\n    setDownlinks(downLinks: IReference[]): Item;\n    addDownlink(id: string, title?: string): Item;\n    removeDownlink(id: string): Item;\n    getUplinks(): IReference[];\n    hasUplink(id: string): boolean;\n    setUplinks(upLinks: IReference[]): Item;\n    addUplink(id: string, title?: string): Item;\n    removeUplink(id: string): Item;\n\n    // Conversion to lower-level structure for interaction with REST APIs\n    extractData(): IItemPut;\n\n    // Label support\n    getLabels(): string[];\n    setLabels(newLabels: string[]): Item;\n    setLabel(labelToSet: string): Item;\n    unsetLabel(labelToUnset: string): Item;\n\n    // Clean/dirty information\n    needsSave(): boolean;\n\n    // Information on Category Fields\n    hasFieldId(fieldId: number): boolean;\n    getFieldById(fieldId: number): Field;\n    getFieldByName(fieldName: string): Field[];\n    getSingleFieldByName(fieldName: string): Field;\n    getFieldsByType(fieldType: string): Field[];\n\n    // Support for partial items (not all Fields from the Category are available)\n    hasAllFields(): boolean;\n    getFieldMask(): ItemFieldMask;\n    expandFieldMaskWithEmptyField(fieldId: number): Field;\n\n    // Support for notifications (\"todos\")\n    createTodo(users: string[], type: TodoTypes, text: string, atDate: Date): Promise&lt;string&gt;;\n    getTodos(includeDone?: boolean, includeAllUsers?: boolean, includeFuture?: boolean): Promise&lt;GetTodosAck&gt;;\n\n    // Conversion to a helper class for DOC Items.\n    toDocItem(): Promise&lt;DocItem&gt;;\n}\n</code></pre> We'll continue looking into Items later on in the guide.</p>"},{"location":"#folder-structure","title":"Folder structure","text":"<p>A Matrix Project has a tree structure, with Items organized into Folders. A Folder is also a type of Item. TreeFolders are objects that emphasize the tree/folder structure. They are also cached, so you can query through them efficiently. Use TreeFolder for tasks involving moving Items around. We can examine the tree like so:</p> get-project-tree.js<pre><code>/*\nThe data output by this function was run through D3 on ObservableHQ.com with the following settings.\nVariable treeData below contained the array of strings output by this program.\nPlot.plot({\n  axis: null,\n  height: 1400,\n  margin: 20,\n  marginRight: 120,\n  marks: [\n    Plot.tree(treeData, {textStroke: \"white\"})\n  ]\n})\n*/\nconst lib = require(\"./lib.js\");\n\nfunction convertToTreePaths(treeFolder) {\n    let obj = [];\n    const itemChildren = treeFolder.getItemChildren();\n    const folderChildren = treeFolder.getFolderChildren();\n    if (itemChildren.length == 0 &amp;&amp; folderChildren.length == 0) {\n        obj.push(treeFolder.getPath());\n        return obj;\n    }\n\n    for (let item of itemChildren) {\n        obj.push(treeFolder.getPath() + \"/\" + item.title);\n    }\n\n    for (let folder of folderChildren) {\n        let childData = convertToTreePaths(folder);\n        obj = obj.concat(childData);\n    }\n    return obj;\n}\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    // List the projects available on this server:\n    const project = await server.openProject(\"WHEELY_OBSERVABLE\");\n    const wheelyTree = await project.getProjectTree();\n    const mytree = convertToTreePaths(wheelyTree);\n    console.log(mytree);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Running this program produces a list of full paths, which can be displayed in a fancy graph (I did this offline with the D3 graphics library).</p> <pre><code>mstanton@darkstar:~/examples/users-guide (main)$ node get-project-tree.js\n[\n  '/Reports/Project Analysis and Management/Design/Design Items',\n  '/Reports/Project Analysis and Management/Risks/Risk Analysis Report',\n  '/Reports/Project Analysis and Management/Testing/Test Design',\n  '/Reports/Project Analysis and Management/Testing/Test Execution Status Planning',\n  '/Reports/Project Analysis and Management/Testing/Test Forms',\n  '/Reports/Project Analysis and Management/Traceability/Traceability Issue Report',\n  '/Reports/Project Analysis and Management/Traceability/Traceability Report',\n  '/Reports/Project Analysis and Management/Traceability/Outdated Traces',\n  ...\n</code></pre> <p></p> <p>The most important methods on TreeFolder are (again, you can visit the full docs for TreeFolder here):</p> TreeFolder method Comments isRoot() is this the root folder for the Category? getId() getTitle() getParent() getPath() Creates a path string including all ancestor folder titles, separated by \"/\" findFolder(folderId) Returns a TreeFolder under the current folder, if it is a descendent findDirectFolderByTitle(folderTitle) Finds a child folder with the given title if present saveInFolder(item) moveItemsToThisFolder(itemIds) given an array of Item Ids, moves them to the present folder deleteChildItemOrFolder(itemId, force) getItem() get the Item that matches this TreeFolder object getFolderChildren() returns an array of TreeFolder objects. If not yet loaded, visits the server getItemChildren() returns an array of title/id pairs for the Items in this folder getAllChildren() returns title/id pairs for all Items, including Folders in this folder <p>Continue with Part II of this guide to dive into advanced searching. Thanks for your time!</p>"},{"location":"part2/","title":"Advanced Searching","text":"<p>This document is part of an guide to using the Matrix Requirements SDK (github page here, and part one of this guide here). We'll continue working in the Node environment established in part one.</p> <p>We've already seen the method <code>Project.searchForIds()</code> which takes a query string and returns a list of Item IDs. But we may want to execute more sophisticated searches, and for this we have two methods:</p> <ul> <li><code>searchForItems(term, filter, treeOrder, mask)</code> which returns an array of <code>Item</code> objects, and</li> <li><code>searchRaw(term, options)</code> which returns an array of <code>ISearchResult</code> objects.</li> </ul> <p>The methods do the same thing, but searchForItems is designed to be friendlier to work with.</p>"},{"location":"part2/#searching-with-a-mask","title":"Searching with a mask","text":"<p>We'll create a mask that gives us back partial Items with only one field brought down from the server:</p> partial-search-1.js<pre><code>const assert = require(\"assert\");\nconst lib = require(\"./lib.js\");\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    const wheely = await server.openProject(\"WHEELY_OBSERVABLE\");\n    // Construct a mask that includes fields, but no labels or up or down links.\n    let mask = wheely.constructSearchFieldMask({ includeFields: true });\n    const catREQ = wheely.getCategory(\"REQ\");\n    const descriptionFieldId = catREQ.getFieldIdFromLabel(\"Description\")[0];\n    mask.addMask(catREQ, [descriptionFieldId]);\n\n    // Now bring down all Items of category REQ with this field mask.\n    const reqs = await wheely.searchForItems(\"mrql:category=REQ\", \"\", false, mask);\n\n    let rows = [];\n    for (let i = 0; i &lt; Math.min(5, reqs.length); i++) {\n        const item = reqs[i];\n        assert(!item.hasAllFields());\n        assert(item.hasFieldId(descriptionFieldId));\n\n        const id = item.getId();\n        const title = item.getTitle();\n        const descriptionField = item.getSingleFieldByName(\"Description\").getHandler();\n        const description = descriptionField.getHtml();\n        rows.push(`&lt;tr&gt;&lt;td&gt;${id}&lt;/td&gt;&lt;td&gt;${title}&lt;/td&gt;&lt;td&gt;${description}&lt;/td&gt;&lt;/tr&gt;`);\n    }\n    console.log(`&lt;table&gt;${rows.join('\\n')}&lt;/table&gt;`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Note that we asserted that the Items brought down only have the one Category REQ field we asked for, \"Description\". Typical HTML output is below:</p> REQ-1Design / LooksThe wheelchair should not look like a medical device but like something which looks nice to kids from 6 to 10 years. REQ-2Sized for KidsThe wheelchair should fit all standard heights and weights for kids from 6 to 12 years of age. 3 to 15 Years<p>Boys</p><p>Average Values</p><p>Normal Range</p><p>Age (Years)</p><p>Weight (Pounds)</p><p>Length (Inches)</p><p>Weight (Pounds)</p><p>Length (Inches)</p><p>2</p><p>27.5</p><p>34.2</p><p>22.8-33.0</p><p>31.7-36.3</p><p>3</p><p>31.0</p><p>37.5</p><p>26.1-38.5</p><p>35.2-39.8</p><p>4</p><p>36.0</p><p>40.3</p><p>29.0-44.0</p><p>37.5-43.2</p><p>5</p><p>40.5</p><p>43.0</p><p>33.0-52.5</p><p>39.8-45.7</p><p>6</p><p>45.5</p><p>45.5</p><p>36.5-59.0</p><p>42.2-48.6</p><p>7</p><p>50.5</p><p>48.0</p><p>40.5-68.0</p><p>44.5-51.3</p><p>8</p><p>56.5</p><p>50.4</p><p>45.0-77.0</p><p>46.7-54.3</p><p>9</p><p>63.0</p><p>52.5</p><p>49.5-88.0</p><p>48.7-56.5</p><p>10</p><p>70.5</p><p>54.5</p><p>56.0-100.5</p><p>50.5-58.8</p><p>11</p><p>78.5</p><p>56.5</p><p>60.5-114.0</p><p>52.0-61.0</p><p>12</p><p>88.0</p><p>58.7</p><p>66.5-130.0</p><p>54.0-63.5</p><p>13</p><p>100.0</p><p>61.5</p><p>74.5-144.0</p><p>56.3-66.6</p><p>14</p><p>112.0</p><p>64.5</p><p>84.0-159.5</p><p>59.1-69.7</p><p>15</p><p>123.5</p><p>67.0</p><p>92.5-172.5</p><p>61.6-71.7</p> REQ-3WheelsThere must be 4 wheels makes it better REQ-4SeatThere must be a seat which<ul><li>is comfortable for extended periods of sitting (&gt; 8 hours)</li><li>can be cleaned easily</li></ul> REQ-5Tablet / Ipad  HolderThe wheelchair must allow to attach a table from 7\" to 11\""},{"location":"part2/#masking-across-multiple-categories","title":"Masking across multiple Categories","text":"<p>What if we are looking for the Description field if we have a REQ Item, and the Use Case Steps field if we have a UC item? No problem! You can construct the mask so that it will apply correctly to each kind of item returned:</p> partial-search-2.js<pre><code>const assert = require(\"assert\");\nconst lib = require(\"./lib.js\");\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    const wheely = await server.openProject(\"WHEELY_OBSERVABLE\");\n\n    // Construct a mask that includes fields, but no labels or up or down links.\n    let mask = wheely.constructSearchFieldMask({ includeFields: true });\n\n    const catREQ = wheely.getCategory(\"REQ\");\n    const descriptionFieldId = catREQ.getFieldIdFromLabel(\"Description\")[0];\n    mask.addMask(catREQ, [descriptionFieldId]);\n\n    const catUC = wheely.getCategory(\"UC\");\n    const ucStepsFieldId = catUC.getFieldIdFromLabel(\"Use Case Steps\")[0];\n    mask.addMask(catUC, [ucStepsFieldId]);\n\n    // Now bring down all Items of category REQ and UC with this field mask.\n    const reqs = await wheely.searchForItems(\"mrql:category=REQ or category=UC\", \"\", false, mask);\n\n    let reqCount = 0, ucCount = 0;\n    for (let i = 0; i &lt; reqs.length; i++) {\n        const item = reqs[i];\n        assert(!item.hasAllFields());\n\n        if (item.getCategory() == catUC) {\n            assert(item.hasFieldId(ucStepsFieldId));\n            ucCount++;\n        } else if (item.getCategory() == catREQ) {\n            assert(item.hasFieldId(descriptionFieldId));\n            reqCount++;\n        }\n    }\n    console.log(`Project has ${reqCount} REQ Items, and ${ucCount} UC Items`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Run this program for the following result:</p> <pre><code>mstanton@darkstar:~/examples/users-guide (main)$ node partial-search-2\nProject has 22 REQ Items, and 3 UC Items\nmstanton@darkstar:~/examples/users-guide (main)$ \n</code></pre>"},{"location":"part2/#category-object-also-returns-search-results","title":"Category object also returns search results","text":"<p>If you want to get all the items for a particular Category, you can request this directly from the Category object without using one of the search methods already mentioned, see line 15 below. And you can still use a mask to retrieve partial items if you like.</p> partial-search-3.js<pre><code>const assert = require(\"assert\");\nconst lib = require(\"./lib.js\");\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    const wheely = await server.openProject(\"WHEELY_OBSERVABLE\");\n\n    // Construct a mask that includes fields, but no labels or up or down links.\n    let mask = wheely.constructSearchFieldMask({ includeFields: true });\n\n    const catUC = wheely.getCategory(\"UC\");\n    const ucStepsFieldId = catUC.getFieldIdFromLabel(\"Use Case Steps\")[0];\n    mask.addMask(catUC, [ucStepsFieldId]);\n\n    const UCs = await catUC.getItems({ mask });\n    let total = 0;\n    for (let uc of UCs) {\n        assert(!uc.hasAllFields());\n        assert(uc.hasFieldId(ucStepsFieldId));\n\n        const fieldHandler = uc.getFieldById(ucStepsFieldId).getHandler();\n        total += fieldHandler.getRowCount();\n    }\n    console.log(`The average number of Use Case Steps in UC Items is ${total / UCs.length}`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>And the output follows:</p> <pre><code>mstanton@darkstar:~/examples/users-guide (main)$ node partial-search-3\nThe average number of Use Case Steps in UC Items is 5.666666666666667\nmstanton@darkstar:~/examples/users-guide (main)$ \n</code></pre>"},{"location":"part2/#a-search-retrieving-label-information","title":"A search retrieving Label information","text":"<p>Of course, maybe you don't want any Fields to be brought down at all, only, say, labels. It's all in the <code>constructSearchFieldMask()</code> function which takes a helper object:</p> <pre><code>  * includeFields      default true\n  * includeLabels      default true\n  * includeDownlinks   default false\n  * includeUplinks     default false\n\n  For example:\n    mask = constructSearchFieldMask({ includeFields: false, includeUplinks: true });\n</code></pre> <p>Let's have a code example where we get Item objects, but no Category Fields, thus reducing download time. We get all the labels and print out the ones we found:</p> partial-search-4.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    const wheely = await server.openProject(\"WHEELY_OBSERVABLE\");\n\n    // Construct a mask that only includes labels.\n    let mask = wheely.constructSearchFieldMask({ includeLabels: true });\n\n    const catUC = wheely.getCategory(\"UC\");\n    const ucStepsFieldId = catUC.getFieldIdFromLabel(\"Use Case Steps\")[0];\n    mask.addMask(catUC, [ucStepsFieldId]);\n\n    const items = await wheely.searchForItems(\"mrql:category=TC\", \"\", false, mask);\n    let foundLabels = new Set();\n    for (let item of items) {\n        for (let label of item.getLabels()) {\n            foundLabels.add(label);\n        }\n    }\n    let output = [];\n    for (let l of foundLabels.values()) output.push(l);\n    console.log(`Found the following labels on TC Items: ${output.join(\", \")}`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>And the output:</p> <pre><code>mstanton@darkstar:~/examples/users-guide (main)$ node partial-search-4.js\nFound the following labels on TC Items: ORANGE, NIGHTTIME, FORPRINTING, APPLE\nmstanton@darkstar:~/examples/users-guide (main)$ \n</code></pre> <p>Cool, we can see our Labels on TCs.</p>"},{"location":"part2/#raw-low-level-search-results","title":"\"Raw\" (low-level) search results","text":"<p>If you want, you can go more \"old school\" and use method <code>searchRaw()</code> which takes parameter fieldList. You can use the mask as we've described to come up with your field mask, and then you can ask the mask for it's fieldMaskString in order to fill in that parameter correctly. Note that the field IDs are referenced, because those are unique:</p> partial-search-5.js<pre><code>const lib = require(\"./lib.js\");\n\nfunction getMaskString(project) {\n    // Construct a mask for the purposes of getting a mask field string\n    let mask = project.constructSearchFieldMask({ includeFields: true });\n    const catREQ = project.getCategory(\"REQ\");\n    mask.addMaskByNames(catREQ, [\"Description\"]);\n    const catUC = project.getCategory(\"UC\");\n    mask.addMaskByNames(catUC, [\"Use Case Steps\"]);\n    return mask.getFieldMaskString();\n}\n\nasync function run() {\n    const server = await lib.getServerConnection(\"clouds5\");\n    const wheely = await server.openProject(\"WHEELY_OBSERVABLE\");\n    const maskString = getMaskString(wheely);\n    let searchResults = await wheely.searchRaw(\"mrql:category=REQ or category=UC\", \"\", maskString);\n    for (let result of searchResults) {\n        const strValue = JSON.stringify(result);\n        console.log(`${strValue.substring(0, 60)}...`);\n    }\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>The output of <code>searchRaw</code> isn't wrapped into Item objects, but remains in a low-level type:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk/examples/users-guide (main)$ node partial-search-5\n{\"itemId\":\"REQ-1\",\"version\":3,\"title\":\"Design / Looks\",\"down...\n{\"itemId\":\"REQ-2\",\"version\":3,\"title\":\"Sized for Kids\",\"down...\n{\"itemId\":\"REQ-3\",\"version\":24,\"title\":\"Wheels\",\"downlinks\":...\n{\"itemId\":\"REQ-4\",\"version\":1,\"title\":\"Seat\",\"downlinks\":[],...\n...\n</code></pre>"},{"location":"part2/#continuous-log-of-rest-requests","title":"Continuous Log of REST requests","text":"<p>The SDK also has information about the REST calls made to the server over time. There is a list of the calls made. You might use this list to verify that only one call was made for a powerful search request.</p> search-fetchlog.js<pre><code>const lib = require(\"./lib.js\");\n\nlib.getServerConnection(\"clouds5\").then((server) =&gt; {\n    server.openProject(\"WHEELY_OBSERVABLE\").then(async (project) =&gt; {\n        project.searchForItems(\"mrql:category=REQ or category=UC\").then((items) =&gt; {\n            console.log(server.getFetchLog().join(\"\\n\"));\n        });\n    });\n});\n</code></pre> <p>The code above was written in the classic Node style using <code>Promises</code> rather than <code>async/await</code> just for fun. After running, you can see 3 calls were made to the server:</p> <pre><code>mstanton@darkstar:~/examples/users-guide (main)$ node search-fetchlog\nhttps://clouds5.matrixreq.com/rest/1/\nhttps://clouds5.matrixreq.com/rest/1/WHEELY_OBSERVABLE?adminUI=1\nhttps://clouds5.matrixreq.com/rest/1/WHEELY_OBSERVABLE/needle\nmstanton@darkstar:~/examples/users-guide (main)$ \n</code></pre> <p>One for Server information. The second call for Project information. The final request (\"needle\") is the search. We were finding needles in haystacks today!</p> <p>Have a look at Part 3 of the User's Guide for more information on saving items, uplinks and downlinks between items, labels and attachments. Thanks for your time!</p>"},{"location":"part3/","title":"Links, Labels and Item Creation","text":"<p>Matrix is designed such that items of a particular Category may link to other items of some particular Categories. For example, a Requirement should link to a Specification. A Specification to a Test, and a Test to an Executed Test. We call this Traceability in the documentation.</p> <p>You can explore the traceability rules for a project with the <code>ItemConfiguration</code> class. Let's focus on which categories link to each other, and create/edit some links between them. Here I've compiled the information into a drawing showing those categories which have downlinks: </p> relationships.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    const wheelyConfig = wheely.getItemConfig();\n    const data = wheelyConfig.getCategories().map((c) =&gt; { \n      return { cat: c, downLinks: wheelyConfig.getItemConfiguration(c).downLinksRequired }; })\n      .filter((o) =&gt; o.downLinks.length &gt; 0)\n      .map((o) =&gt; `  ${o.cat} -&gt; ${o.downLinks.join(\",\")}`);\n    console.log(`digraph {\\n${data.join('\\n')}\\n rankdir=\"LR\";\\n}`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>You'll see I also added a method to our library to return the server and project, <code>lib.getServerAndProject(connection, projectName)</code>, with appropriate default values for my server.</p> <p>The output, processed with GraphViz:</p> <p>%3REQREQSPECSPECREQ-&gt;SPECTCTCSPEC-&gt;TC</p>"},{"location":"part3/#altering-downlinks-in-one-item","title":"Altering Downlinks in one Item","text":"<p>Let's write a program that finds a random SPEC item which links to a TC. We'll remove the TC link and ensure that our now-changed item doesn't show up in the original query for SPECs which link to TCs. Then we'll put things back as we found them. This demonstrates making changes that affect the server.</p> change-downlink.js<pre><code>const assert = require(\"assert\");\nconst lib = require(\"./lib.js\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    server.setComment(\"Changing for a test\");\n    const mask = wheely.constructSearchFieldMask({ includeDownlinks: true });\n    const query = \"mrql:category=SPEC and downLink=TC\";\n    const specsWithTCs = await wheely.searchForItems(query, \"\", false, mask);\n    const itemIndex = Math.floor(Math.random() * specsWithTCs.length);\n    let spec = specsWithTCs[itemIndex];\n    console.log(\n        `Found ${specsWithTCs.length} SPEC Items that have TC downlinks. Choosing ${spec.getId()} at random.`);\n\n    const oldDownlinks = [...spec.getDownlinks()];  // Ensure we copy the array, as we need it later.\n    assert(oldDownlinks.length &gt; 0);\n    console.log(`${spec.getId()} linked to ${oldDownlinks[0].to}`);\n    spec.removeDownlink(oldDownlinks[0].to);\n\n    spec = await wheely.updateItem(spec);\n\n    console.log(`Item updated...re-running search query..`);\n    const query2 = await wheely.searchForItems(query, \"\", false, mask);\n    // Ensure spec is not present.\n    assert(query2.filter((item) =&gt; item.getId() == spec.getId()).length == 0);\n\n    // set things right again.\n    spec.addDownlink(oldDownlinks[0].to);\n    spec = await wheely.updateItem(spec);\n\n    const query3 = await wheely.searchForItems(query, \"\", false, mask);\n    // Ensure spec is present.\n    assert(query3.filter((item) =&gt; item.getId() == spec.getId()).length == 1);\n    console.log(`Success changing and restoring ${spec.getId()}.`);\n }\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Note line 21 where we save our changes to the server. <code>Project.updateItem()</code> returns a fresh copy of the item. Running the application gives the following output:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node change-downlink\nDebugger attached.\nFound 4 SPEC Items that have TC downlinks. Choosing SPEC-11 at random.\nSPEC-11 linked to TC-4\nItem updated...re-running search query..\nSuccess changing and restoring SPEC-11.\nWaiting for the debugger to disconnect...\nmstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$\n</code></pre>"},{"location":"part3/#labels","title":"Labels","text":"<p>Labels in Matrix are quite sophisticated. In the WHEELY_CLIENT_TESTS project, there is an \"XOR\" label with two values:</p> <ul> <li>DAYTIME</li> <li>NIGHTTIME</li> </ul> <p>If one of these labels is set on an Item, then the other is set, the first label will be removed. The client enforces the label rules. Additionally, labels can be limited to particular categories. Let's try and set the DAYTIME label on a REQ.</p> bad-set-label.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    const reqs = await wheely.searchForItems(\"mrql:category=REQ\");\n    const itemIndex = Math.floor(Math.random() * reqs.length);\n    let req = reqs[itemIndex];\n\n    req.setLabel(\"DAYTIME\");\n }\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Looking at the output, we've been rebuked!</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node bad-set-label\n/Users/mstanton/work/matrix-sdk-docs/codes/node_modules/matrix-requirements-sdk/server/index.js:8535\n                throw new Error(`Category ${this.type} doesn't allow labels`);\n                      ^\n\nError: Category REQ doesn't allow labels\n    at Item.verifyLabelsAllowed (/Users/mstanton/work/matrix-sdk-docs/codes/node_modules/matrix-requirements-sdk/server/index.js:8535:23)\n    at Item.setLabel (/Users/mstanton/work/matrix-sdk-docs/codes/node_modules/matrix-requirements-sdk/server/index.js:8559:14)\n    at run (/Users/mstanton/work/matrix-sdk-docs/codes/bad-set-label.js:9:9)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n\nNode.js v18.11.0\nmstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ \n</code></pre> <p>Note that the exception was thrown on the call to <code>Item.setLabel()</code>, and no trip to the server was made. This is because the SDK has the label configuration locally, and can enforce those rules. Looking at the Label settings, we see that this label only works on TC Items:</p> <p></p> <p>Let's retrieve an existing TC Item and do some experiments. We've also got \"OR\" labels \"ORANGE\" and \"APPLE\" in our Label configuration.</p> set-labels.js<pre><code>const lib = require(\"./lib.js\");\n\nfunction printLabels(item, msg) {\n    const labels = item.getLabels();\n    console.log(`${item.getId()}: ${msg}`);\n    console.log(`  Labels: ${labels.join(\", \")}`);\n}\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    const tcs = await wheely.searchForItems(\"mrql:category=TC\");\n    const itemIndex = Math.floor(Math.random() * tcs.length);\n    let tc = tcs[itemIndex];\n\n    const oldLabels = [...tc.getLabels()];\n    printLabels(tc, \"Initial state\");\n    tc.setLabel(\"DAYTIME\");\n    printLabels(tc, \"After set of DAYTIME (xor label)\");\n    tc.setLabel(\"NIGHTTIME\");\n    printLabels(tc, \"After set of NIGHTTIME (xor label)\");\n    tc.setLabel(\"APPLE\").setLabel(\"ORANGE\");\n    printLabels(tc, \"After set of APPLE and ORANGE (or labels)\");\n    tc.unsetLabel(\"DAYTIME\");\n    printLabels(tc, \"After unset of DAYTIME (should have no effect)\");\n    tc.setLabels([]);\n    printLabels(tc, \"Labels set to empty\");\n    if (tc.needsSave()) {\n        console.log(`${tc.getId()} is dirty, not saving to the server`);\n    }\n }\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Running the code above, we get:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node set-labels\nTC-1: Initial state\n  Labels: ORANGE, NIGHTTIME, FORPRINTING\nTC-1: After set of DAYTIME (xor label)\n  Labels: ORANGE, FORPRINTING, DAYTIME\nTC-1: After set of NIGHTTIME (xor label)\n  Labels: ORANGE, FORPRINTING, NIGHTTIME\nTC-1: After set of APPLE and ORANGE (or labels)\n  Labels: ORANGE, FORPRINTING, NIGHTTIME, APPLE\nTC-1: After unset of DAYTIME (should have no effect)\n  Labels: ORANGE, FORPRINTING, NIGHTTIME, APPLE\nTC-1: Labels set to empty\n  Labels: \nTC-1 is dirty, not saving to the server\nmstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ \n</code></pre> <p>Note that the DAYTIME label was removed when we set NIGHTTIME. Whereas the APPLE and ORANGE labels should not toggle on or off as we set one or the other. They are \"OR\" labels, not \"XOR\" labels.</p>"},{"location":"part3/#item-creation","title":"Item creation","text":"<p>The SDK is designed to support you in creating new Items. Generally, no trip to the server is necessary during construction of an Item. Once the Project configuration is locally available, Fields and Labels can be set in a validated way, as demonstrated above with Labels.</p> <p>The important methods for creating and saving Items are on the Project.</p> <ul> <li><code>Project.createItem(category: string): Item</code> - No trip to the server is made. An Item with no Id is returned.</li> <li><code>Project.putItem(folderId: string, item: Item): Promise&lt;Item&gt;</code> - Save an Item with no Id to the server.</li> <li><code>Project.updateItem(item: Item): Promise&lt;Item&gt;</code> - update an existing Item.</li> <li><code>Project.deleteItem(itemId: string, force?: boolean)</code> - Force must be true if the Item is a FOLDER with children.</li> </ul> <p>Let's create a UC (Use Case) object. There is a steplist Field type called \"Use Case Steps\". It will be interesting to see how you add rows to a table:</p> create-uc.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n\n    let uc = wheely.createItem(\"UC\");\n    const title = \"Test \" + performance.now().toString();\n    uc.setTitle(title);\n    uc.getFieldByName(\"Description\")[0].getHandler().setHtml(\"This is a test\");\n    let tableHandler = uc.getFieldByName(\"Use Case Steps\")[0].getHandler();\n    tableHandler.insertRow(0, [\"Open fridge\", \"Fridge door opens\"]);\n    tableHandler.insertRow(1, [\"Get milk\", \"Milk is in hand\"]);\n    tableHandler.insertRow(2, [\"Drink milk\", \"Milk is gone\"]);\n\n    const columnName = tableHandler.columnNumberToFieldId(0);\n    tableHandler.setColumnData(2, columnName, \"Throw milk away\");\n\n    server.setComment(\"Saving our first Item\");\n    uc = await wheely.putItem(\"F-UC-1\", uc);\n    console.log(`Created Item ${uc.getId()}`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Running gives the output <code>Created Item UC-4</code> on my server, with the following screenshot:</p> <p></p> <p>It turns out the milk is spoiled! We can change \"Drink milk\" in the 3rd row of the table like so:</p> <pre><code>    const columnName = tableHandler.columnNumberToFieldId(0);\n    tableHandler.setColumnData(2, columnName, \"Throw milk away\");\n    // Be sure to update the server!\n</code></pre> <p>Let's make a program that does all of that then deletes the Item, so we don't leave our database a mess.</p> create-uc-cleanup.js<pre><code>const assert = require(\"assert\");\nconst lib = require(\"./lib.js\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n\n    let uc = wheely.createItem(\"UC\");\n    const title = \"Test \" + performance.now().toString();\n    uc.setTitle(title);\n    uc.getFieldByName(\"Description\")[0].getHandler().setHtml(\"This is a test\");\n    let tableHandler = uc.getFieldByName(\"Use Case Steps\")[0].getHandler();\n    tableHandler.insertRow(0, [\"Open fridge\", \"Fridge door opens\"]);\n    tableHandler.insertRow(1, [\"Get milk\", \"Milk is in hand\"]);\n    tableHandler.insertRow(2, [\"Drink milk\", \"Milk is gone\"]);\n\n    server.setComment(\"Saving our first Item\");\n    uc = await wheely.putItem(\"F-UC-1\", uc);\n    console.log(`Created Item ${uc.getId()}`);\n\n    // We should get the tableHandler again, because we have a new uc object.\n    const columnName = tableHandler.columnNumberToFieldId(0);\n    tableHandler = uc.getFieldByName(\"Use Case Steps\")[0].getHandler();\n    tableHandler.setColumnData(2, columnName, \"Throw milk away\");\n    uc = await wheely.updateItem(uc);\n    console.log(`Updated Item ${uc.getId()}`);\n\n    // Verify the change in the new object.\n    tableHandler = uc.getFieldByName(\"Use Case Steps\")[0].getHandler();\n    assert(tableHandler.getColumnData(2, columnName) == \"Throw milk away\");\n\n    await wheely.deleteItem(uc.getId());\n    console.log(`Deleted Item ${uc.getId()}`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>After running that, you can look at the changes made on your Matrix Project, and you'll see the delete mentioned at the top:</p> <p></p>"},{"location":"part3/#uploading-image-attachments","title":"Uploading image attachments","text":"<p>A Richtext Field can display images. When we upload an attachment to the server, we're given back information we can turn into a URL to retrieve the image from the server again. Let's just try uploading an image and printing the URL returned by the server. We need the Axios library to do this. To load Axios into your project, run the following at the command prompt:</p> <pre><code>npm install axios\n</code></pre> <p>Below, we pass the Axios library to <code>Project.uploadLocalFile()</code> as the first parameter. We also need to create stream for the file on line 10.</p> upload-image.js<pre><code>const fs = require(\"fs\");\nconst lib = require(\"./lib.js\");\nconst axios = require(\"axios\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    server.setComment(\"Creating attachment\");\n\n    const filePath = __dirname + \"/resources/typewriter.jpg\";\n    let file = fs.createReadStream(filePath);\n    let result = await wheely.uploadLocalFile(axios, file, (p) =&gt; {\n        console.log(\"Uploading...\");\n    });\n\n    // Convert the result to a url\n    const url = wheely.computeFileUrl(result);\n    console.log(`Visit ${url} to get your file`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>You'll see output like this:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node upload-image\nUploading...\nUploading...\nVisit https://clouds5.matrixreq.com/rest/1/WHEELY_OBSERVABLE/file/11075?key=key_elnjk70etp7p1qadc5vuqss634 to get your file\nmstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ \n</code></pre> <p>Note that we're getting the image with <code>https</code>, but it is possible to get it without authentication. Just change the protocol to <code>http</code>. You can alter this on your Matrix server, such that all images require authentication.</p> <p>To add an uploaded image to a Richtext field, simply reference the URL in an html <code>img</code> tag, like so:</p> place-image.js<pre><code>const fs = require(\"fs\");\nconst lib = require(\"./lib.js\");\nconst axios = require(\"axios\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    server.setComment(\"Creating attachment\");\n\n    const filePath = __dirname + \"/resources/typewriter.jpg\";\n    let file = fs.createReadStream(filePath);\n    let result = await wheely.uploadLocalFile(axios, file, (p) =&gt; {\n        console.log(\"Uploading...\");\n    });\n\n    // Convert the result to a url\n    const url = wheely.computeFileUrl(result);\n\n    // Find a UC and add the image to the bottom of the description.\n    wheely.getCategory(\"UC\").create\n    const ucIds = await wheely.searchForIds(\"mrql:category=UC\");\n    // Take the first one.\n    let uc = await wheely.getItem(ucIds[0]);\n    let handler = uc.getFieldByName(\"Description\")[0].getHandler();\n    let text = handler.getHtml();\n    text += `Adding an image with the SDK: &lt;img width=\"400\" src=\"${url}\"&gt;&lt;br&gt;`;\n    handler.setHtml(text);\n    uc = await wheely.updateItem(uc);\n    console.log(`Added image to ${uc.getId()}`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Running at the command prompt reveals:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node place-image\nUploading...\nUploading...\nAdded image to UC-1\n</code></pre> <p>Which looks like this in the Matrix application:</p> <p></p>"},{"location":"part3/#file-attachments","title":"File Attachments","text":"<p>You can also upload attachments to be stored by <code>fileManager</code> fields. I've added a <code>fileManager</code> field to category SPEC, and attached a file. Our FieldHandler for the <code>fileManager</code> field type is bare-bones, only providing the <code>getData()</code> and <code>setData(string)</code> methods that every FieldHandler provides. We'll have to examine the data format in order to work with it correctly.</p> get-attachments.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    let spec = await wheely.getItem(\"SPEC-2\");\n    let handler = spec.getFieldByName(\"Files\")[0].getHandler();\n    let fileData = JSON.parse(handler.getData());\n    console.dir(fileData, { depth: null, colors: true });\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>The code above prints out the JSON object it expects in the <code>fileManager</code> field:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node get-attachments\n[\n  {\n    fileName: 'cdt-overview.jpg',\n    fileId: '11085?key=key_fb77i3bti07cku2dp1f7lcglib'\n  }\n]\nmstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ \n</code></pre> <p>The data format of the field is an array of <code>{fileName, fileId}</code> tuples, where <code>fileId</code> is a concatenation of two fields in the AddFileAck structure returned by <code>Project.uploadLocalFile()</code> and <code>Project.uploadFile()</code>, <code>fileId</code> and <code>key</code>.</p> <p>Let's try our hand at uploading a second file and saving it:</p> upload-file-manager.js<pre><code>const fs = require(\"fs\");\nconst lib = require(\"./lib.js\");\nconst axios = require(\"axios\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n\n    // Upload the file.\n    server.setComment(\"Creating attachment\");\n    const filePath = __dirname + \"/resources/typewriter.jpg\";\n    let file = fs.createReadStream(filePath);\n    const addFileAck = await wheely.uploadLocalFile(axios, file);\n    console.log(`Uploaded ${filePath} to ${wheely.computeFileUrl(addFileAck)}`);\n\n    // Save to \"Files\" in SPEC-2.\n    let spec = await wheely.getItem(\"SPEC-2\");\n    let handler = spec.getFieldByName(\"Files\")[0].getHandler();\n    // the field may have no data (undefined or empty string).\n    let fileData = [];\n    if (handler.getData() !== undefined &amp;&amp; handler.getData() !== \"\") {\n        fileData = JSON.parse(handler.getData());\n    }\n    fileData.push({\n        fileName: \"typewriter.jpg\",\n        fileId: `${addFileAck.fileId}?key=${addFileAck.key}`\n    });\n    console.dir(fileData, { depth: null, colors: true });\n    handler.setData(JSON.stringify(fileData));\n    spec = await wheely.updateItem(spec);\n    console.log(`Updated ${spec.getId()}`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Running at the command prompt, we get:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node upload-file-manager\nUploaded /Users/mstanton/work/matrix-sdk-docs/codes/resources/typewriter.jpg to\n https://clouds5.matrixreq.com/rest/1/WHEELY_OBSERVABLE/file/11088?key=key_r8ovlj5cf9d1o53t5qfhli9p9r\n[\n  {\n    fileName: 'cdt-overview.jpg',\n    fileId: '11085?key=key_fb77i3bti07cku2dp1f7lcglib'\n  },\n  {\n    fileName: 'typewriter.jpg',\n    fileId: '11088?key=key_r8ovlj5cf9d1o53t5qfhli9p9r'\n  }\n]\nUpdated SPEC-2\nmstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ \n</code></pre> <p>Looking at SPEC-2 in the Matrix application, we can see we've got two attachments that can be downloaded:</p> <p></p> <p>We hope you enjoy using the SDK to solve problems. Beyond this guide, the FAQ and Reference documentation may be helpful.</p>"},{"location":"ref/","title":"Reference","text":"<p>Reference documentation is automatically generated by our build process.</p> <p>Click here to open the docs in another tab.</p>"},{"location":"zee-faq/","title":"FAQ","text":"<p>The SDK is brand new so there are plenty of things we haven't thought about yet. This FAQ contains answers to questions you're likely to have at some point.</p>"},{"location":"zee-faq/#what-about-saving-server-settings","title":"What about saving server settings?","text":"<p>This is easy with <code>Server.getServerSettings()</code>, as demonstrated in the program below:</p> server-setting.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    const settings = await server.getServerSettings();\n    let favorites = settings.settingList.filter((setting) =&gt; setting.key === \"favorites\");\n    let favorite = {};\n    if (favorites.length &gt; 0) {\n        console.log(\"Found existing favorites\");\n        favorite = JSON.parse(favorites[0].value);\n    } else {\n        favorite = {\n            car: \"Mustang\",\n            food: \"Tacos\",\n            music: \"Post-rock\"\n        };\n        await server.putServerSetting(\"favorites\", JSON.stringify(favorite));\n        console.log(\"Saved favorites\");\n    }\n    console.dir(favorite);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Note that we get a <code>favorites</code> setting, and create a simple object with our favorite things in it if the setting doesn't exist yet. Here are two runs of the program:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node server-setting.js\nSaved favorites\n{ car: 'Mustang', food: 'Tacos', music: 'Post-rock' }\nmstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node server-setting.js\nFound existing favorites\n{ car: 'Mustang', food: 'Tacos', music: 'Post-rock' }\n</code></pre>"},{"location":"zee-faq/#how-do-i-create-test-cases-xtc-items","title":"How do I create test cases (XTC Items)?","text":"<p>XTC Items are created by a server-side process from a collection of source items (usually  TC (Test Cases), but it depends on your configuration). You can do this from the SDK by calling <code>Project.execute()</code> and passing an <code>ExecuteParam</code> structure giving the source objects and output folder for the newly-created XTC items.</p> <p>Normally, the <code>ExecuteParam</code> structure is populated with defaults from the Project Test Configuration, which you can set up in the Administration panel here:</p> <p></p> <p>Because this is usually what you want to use as a source for creating XTCs, we have a convenience method <code>Project.createExecuteParamWithDefaults()</code> to fill in the mapping from source item fields to target (XTC) fields. The code below creates a folder \"Test Results\" if it doesn't exist, then kicks off creation of XTCs with <code>Project.execute()</code>:</p> execute-call.js<pre><code>const lib = require(\"./lib.js\");\nconst assert = require(\"assert\");\n\nasync function getOrCreateOutputFolder(project, parent, name) {\n    let tree = await project.getProjectTree();\n    let xtcs = tree.findFolder(parent);\n    let outputFolder = xtcs.findDirectFolderByTitle(name);\n    if (outputFolder == null) {\n        let folderItem = project.createFolder(\"XTC\");\n        folderItem.setTitle(name);\n        folderItem = await project.putItem(parent, folderItem);\n        return folderItem.getId();\n    }\n    return outputFolder.getId();\n}\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    server.setComment(\"Creating XTCs\");\n    let tree = await wheely.getProjectTree();\n    let tcFolder = tree.findFolder(\"F-TC-1\");\n    // We expect the root TC folder to have some items.\n    assert(tcFolder.getItemChildren().length &gt; 0);\n    let param = wheely.createExecuteParamWithDefaults(['F-TC-1'], 'XTC', \n        \"Create XTCs \" + performance.now().toString());\n    param.parentFolder = await getOrCreateOutputFolder(wheely, \"F-XTC-1\", \"Test Results\");\n    console.dir(param);\n    const result = await wheely.execute(param);\n    console.log(`Created folder ${result.folder}`);\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Here is the console output after a run, showing the structure of the <code>ExecuteParam</code> object created for the call to <code>execute()</code>, along with the Id of the folder with the new XTCs:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node execute-call\n{\n  input: [ 'F-TC-1' ],\n  output: 'XTC',\n  reason: 'Create XTCs 1599.5004580020905',\n  itemFieldMapping: [\n    { fromId: 37379, toId: 37383 },\n    { fromId: 37380, toId: 37388 },\n    { fromId: 37381, toId: 37389 },\n    { fromId: 37382, toId: 37390 },\n    { fromId: 37365, toId: 37383 },\n    { fromId: 37366, toId: 37388 },\n    { fromId: 37367, toId: 37389 },\n    { fromId: 37368, toId: 37390 }\n  ],\n  parentFolder: 'F-XTC-59'\n}\nCreated folder F-XTC-62\nmstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$\n</code></pre> <p>And here is the state of the project after running two times:</p> <p>;</p> <p>Note the Folder named \"Test Results\" which we've made serve as the parent folder for generating a set of XTCs.</p>"},{"location":"zee-faq/#how-do-i-deal-with-doc-objects","title":"How do I deal with DOC objects?","text":"<p>A DOC is like a unique, stand-alone <code>Item</code> <code>Category</code>. The DOC describes the fields that it contains, configures the fields, and includes the content for the fields. This makes it a more complex object to work with than an ordinary Item, where configuration is done at the Category level.</p> <p>With that in mind, we've provided the <code>DocItem</code> class, which has all the features of the Item class with some extra helper methods. First, let's bring down an existing DOC and explore it with the DocItem class. In the <code>WHEELY_OBSERVABLE</code> Project we've got <code>DOC-8</code> which is a Design Review. It has a signature field, a summary rich text field and a queried list of reviewed items that show up when the document is rendered.</p> <p>Rather than calling <code>getFields()</code>, you should call <code>getInnerDHFFields()</code> on a <code>DocItem</code>. This is because at its core, the DOC is the same as any other Item, and has a set of Fields, however, the names of the fields are of the form \"dhf01\", \"dhf02\", and so on. Looking at the UI, you see much more useful names like \"Signatures\" and \"Review Summary.\" Method <code>getInnerDHFFields()</code> allows you to use those human-readable names and see the configuration for the fields easily too.</p> <p>Let's list the field names in the DOC:</p> get-doc-8.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n\n    let doc = await wheely.getItemAsDoc(\"DOC-8\");\n    const handlers = doc.getInnerDHFFields();\n    console.log(`Fields in DOC-8:`);\n    for (let handler of handlers) {\n        console.log(`\"${handler.getFieldName()}\" [${handler.getFieldType()}]`);\n    }\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Which gives the following output, showing the user-readable field names and the field types:</p> <pre><code>Fields in DOC-8:\n\"Signatures\" [signaturebox]\n\"Review Summary\" [richtext]\n\"Reviewed Items\" [items]\n</code></pre> <p><code>IDocFieldHandler</code> offers the following methods in addition to what <code>IFieldHandler</code> provides:</p> <pre><code>export interface IDocFieldHandler extends IFieldHandler{\n    dhfFieldConfig: IAnyMap;\n\n    setDHFConfig(config:IAnyMap):void;\n    getDefaultConfig():any;\n    getXmlValue():string;\n\n    getFieldName(): string;\n    setFieldName(value: string): void;\n    addSignatures (signatures: string[], includeAll?:boolean): void;\n}\n</code></pre> <p>We can print the field configuration as a JSON object, and the field data (string or JSON object).</p> get-doc-8-moredetail.js<pre><code>const lib = require(\"./lib.js\");\n\nfunction print(data) {\n    try {\n        console.dir(JSON.parse(data));\n    } catch(e) {\n        console.log(data);\n    }\n}\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n\n    let doc = await wheely.getItemAsDoc(\"DOC-8\");\n    const handlers = doc.getInnerDHFFields();\n    console.log(`Fields in DOC-8:`);\n    for (let handler of handlers) {\n        console.log(`\"${handler.getFieldName()}\" [${handler.getFieldType()}]`);\n        console.group()\n        console.dir(handler.dhfFieldConfig);\n        // Print the value of the field:\n        print(handler.getData());\n        console.groupEnd();\n    }\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>Which gives the following output, showing the user-readable field names and the field types:</p> <pre><code>Fields in DOC-8:\n\"Signatures\" [signaturebox]\n  {\n    columns: [\n      {\n        name: 'Signature Meaning',\n        field: 'col0',\n        columnType: 'type6',\n        pos: 0\n      },\n      { name: 'Name', field: 'col1', columnType: 'type4', pos: 1 },\n      { name: 'Title', field: 'col2', columnType: 'type0', pos: 2 },\n      { name: 'Date', field: 'col3', columnType: 'type5', pos: 3 },\n      { name: 'Signature', field: 'col4', columnType: 'type3', pos: 4 }\n    ]\n  }\n  [\n    { col0: 'Reviewer', col1: 'wolfgang', col2: 'qa engineer' },\n    { col0: 'Reviewer', col1: 'yves', col2: 'product manager' }\n  ]\n\"Review Summary\" [richtext]\n  { page_break: false }\n  The items below have been reviewed whether they are quantifiable for testing purposes.\n\"Reviewed Items\" [items]\n  {\n    breadcrumb: true,\n    extracolumn: '',\n    showlinks: true,\n    page_break: false,\n    folderDetails: '',\n    showUpOnly: false,\n    showDownOnly: false,\n    showDeeplinks: false,\n    showExternal: 0,\n    dateoptions: '',\n    refdocs: false,\n    hideLinkErrors: false,\n    hideLabels: false,\n    showAllParentFolders: false,\n    hideEmptyFolders: false,\n    includeInToc: false,\n    breakAfterItems: false\n  }\n  [ { to: 'F-REQ-1', title: 'Requirements' } ]\n</code></pre> <p>To render and download a DOC as a PDF, you can call <code>toPDF()</code> and <code>downloadJobResult()</code>:</p> get-doc-8-pdf.js<pre><code>const lib = require(\"./lib.js\");\nconst fs = require(\"fs\");\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n\n    let doc = await wheely.getItemAsDoc(\"DOC-8\");\n    let jobId;\n    let jobData;\n    const urlToPDF = await doc.toPDF((jid, details) =&gt; {\n        console.log(`Progress: ${details.progress}%`);\n        if (details.progress == 100) {\n            // When the job is finished, save information on the output.\n            jobId = jid;\n            jobData = details.jobFile;\n        }\n    });\n    if (jobData) {\n        // There are several output files in DOC rendering, focus on the one which is the PDF.\n        let fileInfo = jobData.filter(d =&gt; d.restUrl == urlToPDF)[0];\n        console.log(`Downloading Job ${jobId} File ${fileInfo.jobFileId} as download.pdf...`);\n        let result = await wheely.downloadJobResult(jobId, fileInfo.jobFileId);\n        fs.writeFileSync(\"download.pdf\", Buffer.from(result));\n    }\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>We can render a DOC as PDF, Word or HTML. The program saves the PDF render to disk where it can be opened with any PDF file reader:</p> <pre><code>darkstar:~/matrix-sdk-docs/codes $ node get-doc-8-pdf.js\nProgress: 10%\nProgress: 40%\nProgress: 40%\nProgress: 40%\nProgress: 90%\nProgress: 91%\nProgress: 91%\nProgress: 100%\nDownloading Job 4853 File 7393 as download.pdf...\n</code></pre> <p>;</p>"},{"location":"zee-faq/#how-do-i-run-a-server-hook","title":"How do I run a server hook?","text":"<p>A hook is a server-side job with a unique name that accepts an Item Id and a payload string. Method <code>runHook()</code> on the <code>Project</code> class kicks off the hook. Some hooks return a jobId which can be polled for a result at job completion. <code>Project.waitOnJobCompletion()</code> makes it easy to do that. Example code:</p> <pre><code>...\nconst result = await project.runHook(reqs[0], \"publish_marketplace\", \"\");\nconst jobId = JSON.parse(result).jobId;\nconst jobResult = await project.waitOnJobCompletion(jsonResult.jobId, (jid, progress) =&gt; {\n    console.log(`${jid}: progress ${progress}`);\n});\nconsole.log(`Final result: ${jobResult.length} generated files`);\nif (jobResult.length &gt; 0) {\n    console.dir(jobResult[0], { depth: null, colors: true });\n}\n</code></pre> <p>And output:</p> <pre><code>mstanton@darkstar:~/work/hook-test$ node hook-example\n4783: progress 10\n4783: progress 10\n4783: progress 10\n4783: progress 100\nFinal result: 1 generated files\n{\n  restUrl: 'https://clouds5.matrixreq.com/rest/1/WHEELY_OBSERVABLE/job/4783/7250',\n  jobFileId: 7250,\n  visibleName: 'publishlog.txt',\n  internalPath: '/generated/j4783_publishlog.txt',\n  mimeType: 'text/plain'\n}\nmstanton@darkstar:~/work/hook-test$\n</code></pre>"},{"location":"zee-faq/#why-do-i-have-to-load-the-axios-library-separately","title":"Why do I have to load the Axios library separately?","text":"<p>Currently, we're shipping the Server SDK as a rollup of all our dependencies. For Node this is not ideal, and we plan to load dependencies from the Node environment in a future release. Axios is required for just one call, <code>Project.uploadLocalFile()</code> so we prefered not to bundle it.</p>"},{"location":"zee-faq/#can-i-create-notifications-with-the-sdk","title":"Can I create Notifications with the SDK?","text":"<p>Yes, as long as the feature is enabled on the server. The <code>Item</code> class includes two methods for manipulating \"Todos,\" another name for notifications:</p> <ul> <li>createTodo(users, type, text, atDate) - create a Todo for multiple users and return ids. The <code>type</code> field is a string from the <code>TodoTypes</code> enum</li> <li>getTodos(includeDone, includeAllUsers, includeFuture) - return information on Todos active for this item</li> </ul> <p>Additionally, <code>Project.getTodos()</code> returns information on all Todos active in the Project. Let's create two Todos and verify that they can be found from the `Project`` class:</p> todos.js<pre><code>const lib = require(\"./lib.js\");\n\nasync function run() {\n    const [server, wheely] = await lib.getServerAndProject();\n    let ucs = await wheely.searchForItems(\"mrql:category=UC\");\n    let todoId1 = await ucs[0].createTodo([\"mike\"], \"user\", \"Here is a notification\", new Date());\n    let todoId2 = await ucs[1].createTodo([\"francois\"], \"user\", \"Here is a notification\", new Date());\n    console.log(`Created Todos ${todoId1}, ${todoId2}`);\n    const todos = await wheely.getTodos(undefined, undefined, true);\n    console.dir(todos, {});\n}\n\nrun().then(() =&gt; process.exit(0));\n</code></pre> <p>The returned structure includes all Todos in the project, as well as a summary report of the active Todos for the current user. My API Token is attached to my user account which is <code>mike</code>, so we see that Mike has 1 Todo:</p> <pre><code>mstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ node todos\nCreated Todos 382, 383\n{\n  todos: [\n    {\n      todoId: 383,\n      userId: 7,\n      login: 'francois',\n      projectShort: 'WHEELY_OBSERVABLE',\n      itemRef: 'UC-2',\n      auto: false,\n      originatorUserId: 23,\n      originatorLogin: 'mike',\n      action: [Object],\n      createdAt: '2023-12-24T10:12:38.458Z',\n      createdAtUserFormat: '2023/12/24 10:12:38',\n      future: false\n    },\n    {\n      todoId: 382,\n      userId: 23,\n      login: 'mike',\n      projectShort: 'WHEELY_OBSERVABLE',\n      itemRef: 'UC-1',\n      auto: false,\n      originatorUserId: 23,\n      originatorLogin: 'mike',\n      action: [Object],\n      createdAt: '2023-12-24T10:12:38.352Z',\n      createdAtUserFormat: '2023/12/24 10:12:38',\n      future: false\n    }\n  ],\n  todoCounts: [\n    {\n      userId: 23,\n      login: 'mike',\n      projectId: 360,\n      projectShort: 'WHEELY_OBSERVABLE',\n      nbTodos: 1,\n      firstTodos: [Array]\n    }\n  ]\n}\nmstanton@darkstar:~/work/matrix-sdk-docs/codes (main)$ \n</code></pre> <p>If I log in as <code>mike</code>, I can see the newly created Todo:</p> <p></p> <p>The Matrix server resists creating too many similar Todos. So if the user, date and description are the same as an existing Todo, a new Todo won't be created (-1 will be returned as the Todo Id).</p>"}]}